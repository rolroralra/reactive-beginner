# 예외 처리

## 1. 개요

Spring WebFlux에서는 Reactive Streams의 특성상 기존 Spring MVC와 다른 방식으로 예외를 처리합니다. 이 문서에서는 다양한 예외 처리 방법을 설명합니다.

## 2. Operator 레벨 에러 처리

### 2.1 onErrorReturn

에러 발생 시 기본값을 반환합니다.

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorReturn(User.defaultUser());
}

// 특정 예외 타입에만 적용
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorReturn(NotFoundException.class, User.defaultUser());
}

// Predicate로 조건 지정
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorReturn(e -> e.getMessage().contains("not found"), User.defaultUser());
}
```

### 2.2 onErrorResume

에러 발생 시 대체 Publisher로 전환합니다.

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorResume(e -> {
            log.error("Error fetching user: {}", e.getMessage());
            return Mono.just(User.defaultUser());
        });
}

// 특정 예외 타입별 처리
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorResume(NotFoundException.class, e ->
            Mono.just(User.defaultUser()))
        .onErrorResume(ServiceException.class, e ->
            Mono.error(new ResponseStatusException(HttpStatus.SERVICE_UNAVAILABLE)));
}

// Fallback 서비스 호출
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return primaryService.findById(id)
        .onErrorResume(e -> fallbackService.findById(id));
}
```

### 2.3 onErrorMap

에러를 다른 타입의 에러로 변환합니다.

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .onErrorMap(DataAccessException.class,
            e -> new ServiceException("Database error", e));
}
```

### 2.4 doOnError

에러 발생 시 부수 효과(로깅 등)를 수행합니다. 에러는 그대로 전파됩니다.

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .doOnError(e -> log.error("Error fetching user {}: {}", id, e.getMessage()))
        .doOnError(NotFoundException.class, e -> metrics.increment("user.not.found"));
}
```

### 2.5 onErrorContinue (Flux)

Flux에서 에러가 발생한 요소를 건너뛰고 계속 진행합니다.

```java
@GetMapping
public Flux<User> getAllUsers() {
    return userService.findAll()
        .flatMap(this::enrichUser)
        .onErrorContinue((error, item) ->
            log.warn("Failed to enrich user {}: {}", item, error.getMessage()));
}
```

## 3. @ExceptionHandler

### 3.1 Controller 레벨

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        return userService.findById(id);
    }

    @ExceptionHandler(NotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public Mono<ErrorResponse> handleNotFound(NotFoundException e) {
        return Mono.just(new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            e.getMessage(),
            System.currentTimeMillis()
        ));
    }

    @ExceptionHandler(ValidationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Mono<ErrorResponse> handleValidation(ValidationException e) {
        return Mono.just(new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            e.getMessage(),
            System.currentTimeMillis()
        ));
    }
}

record ErrorResponse(int status, String message, long timestamp) {}
```

### 3.2 @ControllerAdvice (전역 처리)

```java
package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import reactor.core.publisher.Mono;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public Mono<ErrorResponse> handleNotFound(NotFoundException e) {
        return Mono.just(new ErrorResponse(
            "NOT_FOUND",
            e.getMessage(),
            System.currentTimeMillis()
        ));
    }

    @ExceptionHandler(ValidationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Mono<ErrorResponse> handleValidation(ValidationException e) {
        return Mono.just(new ErrorResponse(
            "VALIDATION_ERROR",
            e.getMessage(),
            System.currentTimeMillis()
        ));
    }

    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public Mono<ErrorResponse> handleAccessDenied(AccessDeniedException e) {
        return Mono.just(new ErrorResponse(
            "ACCESS_DENIED",
            "You don't have permission to access this resource",
            System.currentTimeMillis()
        ));
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Mono<ErrorResponse> handleGeneral(Exception e) {
        log.error("Unexpected error", e);
        return Mono.just(new ErrorResponse(
            "INTERNAL_ERROR",
            "An unexpected error occurred",
            System.currentTimeMillis()
        ));
    }
}

record ErrorResponse(String code, String message, long timestamp) {}
```

## 4. ResponseStatusException

간단한 HTTP 상태 코드 기반 예외 처리:

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .switchIfEmpty(Mono.error(
            new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found: " + id)));
}

@PostMapping
public Mono<User> createUser(@RequestBody User user) {
    if (user.getName() == null) {
        return Mono.error(
            new ResponseStatusException(HttpStatus.BAD_REQUEST, "Name is required"));
    }
    return userService.save(user);
}
```

## 5. WebExceptionHandler

가장 낮은 레벨의 전역 예외 처리:

```java
package com.example.exception;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.boot.web.reactive.error.ErrorWebExceptionHandler;
import org.springframework.core.annotation.Order;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
@Order(-2)  // DefaultErrorWebExceptionHandler보다 높은 우선순위
public class GlobalWebExceptionHandler implements ErrorWebExceptionHandler {

    private final ObjectMapper objectMapper;

    public GlobalWebExceptionHandler(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        HttpStatus status = determineStatus(ex);
        ErrorResponse response = new ErrorResponse(
            status.value(),
            status.getReasonPhrase(),
            ex.getMessage(),
            System.currentTimeMillis()
        );

        exchange.getResponse().setStatusCode(status);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);

        return exchange.getResponse().writeWith(
            Mono.fromCallable(() -> {
                byte[] bytes = objectMapper.writeValueAsBytes(response);
                DataBuffer buffer = exchange.getResponse().bufferFactory().wrap(bytes);
                return buffer;
            })
        );
    }

    private HttpStatus determineStatus(Throwable ex) {
        if (ex instanceof NotFoundException) {
            return HttpStatus.NOT_FOUND;
        } else if (ex instanceof ValidationException) {
            return HttpStatus.BAD_REQUEST;
        } else if (ex instanceof AccessDeniedException) {
            return HttpStatus.FORBIDDEN;
        }
        return HttpStatus.INTERNAL_SERVER_ERROR;
    }
}

record ErrorResponse(int status, String error, String message, long timestamp) {}
```

## 6. Functional Endpoints 에러 처리

### 6.1 Handler에서 처리

```java
@Component
public class UserHandler {

    public Mono<ServerResponse> getUser(ServerRequest request) {
        Long id = Long.parseLong(request.pathVariable("id"));

        return userService.findById(id)
            .flatMap(user -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(user))
            .switchIfEmpty(ServerResponse.notFound().build())
            .onErrorResume(IllegalArgumentException.class, e ->
                ServerResponse.badRequest()
                    .bodyValue(new ErrorResponse("BAD_REQUEST", e.getMessage())));
    }
}
```

### 6.2 Filter로 처리

```java
@Configuration
public class RouterConfig {

    @Bean
    public RouterFunction<ServerResponse> routes(UserHandler handler) {
        return route()
            .path("/users", builder -> builder
                .GET("/{id}", handler::getUser)
                .GET("", handler::getAllUsers)
            )
            .filter(errorHandlingFilter())
            .build();
    }

    private HandlerFilterFunction<ServerResponse, ServerResponse> errorHandlingFilter() {
        return (request, next) -> next.handle(request)
            .onErrorResume(NotFoundException.class, e ->
                ServerResponse.notFound().build())
            .onErrorResume(ValidationException.class, e ->
                ServerResponse.badRequest()
                    .bodyValue(new ErrorResponse("VALIDATION_ERROR", e.getMessage())))
            .onErrorResume(Exception.class, e ->
                ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .bodyValue(new ErrorResponse("INTERNAL_ERROR", e.getMessage())));
    }
}
```

## 7. 커스텀 예외 클래스

### 7.1 기본 예외 클래스

```java
package com.example.exception;

public abstract class BaseException extends RuntimeException {

    private final String code;

    protected BaseException(String code, String message) {
        super(message);
        this.code = code;
    }

    protected BaseException(String code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}
```

### 7.2 도메인별 예외

```java
public class NotFoundException extends BaseException {
    public NotFoundException(String message) {
        super("NOT_FOUND", message);
    }

    public static NotFoundException user(Long id) {
        return new NotFoundException("User not found: " + id);
    }

    public static NotFoundException order(String orderId) {
        return new NotFoundException("Order not found: " + orderId);
    }
}

public class ValidationException extends BaseException {
    private final List<String> errors;

    public ValidationException(String message) {
        super("VALIDATION_ERROR", message);
        this.errors = List.of(message);
    }

    public ValidationException(List<String> errors) {
        super("VALIDATION_ERROR", "Validation failed");
        this.errors = errors;
    }

    public List<String> getErrors() {
        return errors;
    }
}

public class ServiceException extends BaseException {
    public ServiceException(String message) {
        super("SERVICE_ERROR", message);
    }

    public ServiceException(String message, Throwable cause) {
        super("SERVICE_ERROR", message, cause);
    }
}
```

## 8. 에러 응답 표준화

### 8.1 RFC 7807 Problem Details

```java
package com.example.exception;

import com.fasterxml.jackson.annotation.JsonInclude;
import java.net.URI;
import java.time.Instant;
import java.util.Map;

@JsonInclude(JsonInclude.Include.NON_NULL)
public record ProblemDetail(
    URI type,
    String title,
    int status,
    String detail,
    URI instance,
    Instant timestamp,
    Map<String, Object> extensions
) {
    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private URI type = URI.create("about:blank");
        private String title;
        private int status;
        private String detail;
        private URI instance;
        private Instant timestamp = Instant.now();
        private Map<String, Object> extensions;

        public Builder type(String type) {
            this.type = URI.create(type);
            return this;
        }

        public Builder title(String title) {
            this.title = title;
            return this;
        }

        public Builder status(int status) {
            this.status = status;
            return this;
        }

        public Builder detail(String detail) {
            this.detail = detail;
            return this;
        }

        public Builder instance(String instance) {
            this.instance = URI.create(instance);
            return this;
        }

        public Builder extensions(Map<String, Object> extensions) {
            this.extensions = extensions;
            return this;
        }

        public ProblemDetail build() {
            return new ProblemDetail(type, title, status, detail, instance, timestamp, extensions);
        }
    }
}
```

### 8.2 ProblemDetail 사용

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NotFoundException.class)
    public Mono<ResponseEntity<ProblemDetail>> handleNotFound(
            NotFoundException e, ServerWebExchange exchange) {
        ProblemDetail problem = ProblemDetail.builder()
            .type("/errors/not-found")
            .title("Resource Not Found")
            .status(HttpStatus.NOT_FOUND.value())
            .detail(e.getMessage())
            .instance(exchange.getRequest().getPath().value())
            .build();

        return Mono.just(ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .contentType(MediaType.APPLICATION_PROBLEM_JSON)
            .body(problem));
    }

    @ExceptionHandler(ValidationException.class)
    public Mono<ResponseEntity<ProblemDetail>> handleValidation(
            ValidationException e, ServerWebExchange exchange) {
        ProblemDetail problem = ProblemDetail.builder()
            .type("/errors/validation")
            .title("Validation Error")
            .status(HttpStatus.BAD_REQUEST.value())
            .detail(e.getMessage())
            .instance(exchange.getRequest().getPath().value())
            .extensions(Map.of("errors", e.getErrors()))
            .build();

        return Mono.just(ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .contentType(MediaType.APPLICATION_PROBLEM_JSON)
            .body(problem));
    }
}
```

## 9. 재시도 전략

```java
@GetMapping("/{id}")
public Mono<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .retryWhen(Retry.backoff(3, Duration.ofMillis(100))
            .maxBackoff(Duration.ofSeconds(1))
            .filter(e -> e instanceof ServiceException)
            .onRetryExhaustedThrow((spec, signal) ->
                new ServiceException("Service unavailable after retries")));
}
```

## 10. 다음 단계

- [Filter와 Interceptor](09_Filter와_Interceptor.md): 필터 기반 에러 처리
- [Testing](10_Testing.md): 에러 시나리오 테스트
- [WebClient](05_WebClient.md): HTTP 클라이언트 에러 처리
